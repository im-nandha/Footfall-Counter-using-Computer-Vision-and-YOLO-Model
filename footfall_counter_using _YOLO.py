# -*- coding: utf-8 -*-
"""footfall counter 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RVLMzHaXhrJ5JkjSt8dsCx8QTXVHczBo
"""

pip install ultralytics opencv-python numpy

from ultralytics import YOLO
import cv2
import numpy as np
from scipy.spatial import distance as dist

# CENTROID TRACKER

class CentroidTracker:
    def __init__(self, maxDisappeared=15, maxDistance=80):
        self.nextObjectID = 0
        self.objects = {}
        self.disappeared = {}
        self.tracks = {}
        self.maxDisappeared = maxDisappeared
        self.maxDistance = maxDistance

    def register(self, centroid):
        self.objects[self.nextObjectID] = centroid
        self.disappeared[self.nextObjectID] = 0
        self.tracks[self.nextObjectID] = [centroid]
        self.nextObjectID += 1

    def deregister(self, objectID):
        del self.objects[objectID]
        del self.disappeared[objectID]

    def update(self, rects):
        if len(rects) == 0:
            for oid in list(self.disappeared.keys()):
                self.disappeared[oid] += 1
                if self.disappeared[oid] > self.maxDisappeared:
                    self.deregister(oid)
            return self.objects

        inputCentroids = np.zeros((len(rects), 2), dtype="int")
        for (i, (x1, y1, x2, y2)) in enumerate(rects):
            cX = int((x1 + x2) / 2.0)
            cY = int((y1 + y2) / 2.0)
            inputCentroids[i] = (cX, cY)

        if len(self.objects) == 0:
            for i in range(len(inputCentroids)):
                self.register(tuple(inputCentroids[i]))
        else:
            objectIDs = list(self.objects.keys())
            objectCentroids = list(self.objects.values())
            D = dist.cdist(np.array(objectCentroids), inputCentroids)
            rows = D.min(axis=1).argsort()
            cols = D.argmin(axis=1)[rows]
            usedRows, usedCols = set(), set()

            for (row, col) in zip(rows, cols):
                if row in usedRows or col in usedCols:
                    continue
                if D[row, col] > self.maxDistance:
                    continue
                objectID = objectIDs[row]
                self.objects[objectID] = tuple(inputCentroids[col])
                self.tracks[objectID].append(tuple(inputCentroids[col]))
                self.disappeared[objectID] = 0
                usedRows.add(row)
                usedCols.add(col)

            unusedRows = set(range(0, D.shape[0])).difference(usedRows)
            unusedCols = set(range(0, D.shape[1])).difference(usedCols)

            for row in unusedRows:
                objectID = objectIDs[row]
                self.disappeared[objectID] += 1
                if self.disappeared[objectID] > self.maxDisappeared:
                    self.deregister(objectID)
            for col in unusedCols:
                self.register(tuple(inputCentroids[col]))

        return self.objects

#LOAD YOLOv8 MODEL

model = YOLO("yolov8n.pt")

#VIDEO SOURCE

video_path = "/content/crowd_video.mp4"
cap = cv2.VideoCapture(video_path)

# Video output setup
fps = int(cap.get(cv2.CAP_PROP_FPS))
w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fourcc = cv2.VideoWriter_fourcc(*'mp4v')
out = cv2.VideoWriter('final_footfall_output.mp4', fourcc, fps, (w, h))

# Initialize Counters
ct = CentroidTracker(maxDisappeared=25, maxDistance=100)
total_in, total_out = 0, 0
roi_y = int(h * 0.5)

# PROCESSING VIDEO FRAME BY FRAME
while True:
    ret, frame = cap.read()
    if not ret:
        break

    results = model(frame, stream=True)
    rects = []
    for r in results:
        for box in r.boxes:
            cls = int(box.cls[0])
            conf = float(box.conf[0])
            if cls == 0 and conf > 0.4:  # person class
                x1, y1, x2, y2 = map(int, box.xyxy[0])
                rects.append((x1, y1, x2, y2))
                cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)

    objects = ct.update(rects)
    cv2.line(frame, (50, roi_y), (w-50, roi_y), (0, 0, 255), 2)

    for (objectID, centroid) in objects.items():
        cX, cY = centroid
        cv2.circle(frame, (cX, cY), 4, (255, 0, 0), -1)
        cv2.putText(frame, f"ID {objectID}", (cX - 10, cY - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

        pts = ct.tracks.get(objectID, [])
        if len(pts) >= 2:
            y_prev = pts[-2][1]
            y_curr = pts[-1][1]
            if y_prev < roi_y and y_curr >= roi_y:
                total_in += 1
            elif y_prev > roi_y and y_curr <= roi_y:
                total_out += 1
        for i in range(1, len(pts)):
            cv2.line(frame, pts[i-1], pts[i], (255, 255, 0), 2)

    # display count box
    cv2.rectangle(frame, (10, 10), (250, 80), (255, 255, 255), -1)
    cv2.putText(frame, f"IN: {total_in}", (20, 40), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 150, 0), 2)
    cv2.putText(frame, f"OUT: {total_out}", (20, 70), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 200), 2)

    out.write(frame)

cap.release()

summary = np.full((h, w, 3), 255, dtype=np.uint8)
cv2.putText(summary, "FINAL FOOTFALL REPORT", (int(w*0.2), int(h*0.3)),
            cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0,0,0), 3)
cv2.putText(summary, f"Total Entries (IN): {total_in}", (int(w*0.25), int(h*0.5)),
            cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0,150,0), 3)
cv2.putText(summary, f"Total Exits (OUT): {total_out}", (int(w*0.25), int(h*0.6)),
            cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0,0,200), 3)

# Write final summary for 3 seconds
for _ in range(int(fps * 3)):
    out.write(summary)

out.release()
print("âœ… Final output video saved as: final_footfall_output.mp4")